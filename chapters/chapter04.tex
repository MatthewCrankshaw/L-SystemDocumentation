
\begin{flushleft}

There are two major parts of an L-systems implementation, firstly there is the L-system rewriter, which takes a defined L-system that complies to a partacular grammar, the starting point will be rewritten a number of times using the set of production rules. The rewriting system will give a set of instructions, sometimes called the resultant string. This resultant string is passed to the second system called the interpreter. The interpreter runs through each character or instruction within the resulting string  and interprets its meaning, this acts as a set of instructions that are carried out by turtle graphics to eventually represent a model of a plant on the screen. This chapter will focus on the rewriting system. This includes formaly defining a context-free grammar which the L-system must obide by. Once the grammar has been formalized, a lexical analyser and parser, similar to those used in interpreters and compilers in computing, can be created to represent the context-free L-system grammar, essentially, creating an compiler for a context-free L-system grammar. Using this compiler we can write an L-system, similar to a computer program, the L-system "program" will be passed into the lexical analyser and then through the parser, where each component of the L-system will be identified and parsed into the appropriate computational structures. If the syntax is valid and the parser is successful, the structures created during parsing will be used to rewrite the L-system to a given generation. If the L-system provided does not match the context-free grammar definition, an appropriate error message can be displayed. \\

\vspace{5mm}

For simple D0L-system seen in section \ref{DOL-system example}, creating a rewriter for a simple DOL-system like this is quite simple, each rewritable symbol is only made up of a single character, and because the D0L-system is deterministic we know that there is no randomess when determining the matching rule. This is just a case of storing the starting string, and then iterating through this string one character at a time and when a symbol matches that in a rule, replace that character with the string provided by the rule. This can be implemented relatively simply, however, to implement the parametric 0L-system, where each instruction is a module with potentually multiple parameters and each parameter could be a mathematical expression, the rewriting system will have to better understand what each part of the L-system is specifying based on the grammar and its context in the L-system. The lexical analyser and parser can be used for this purpose in order to classify each part of the L-system and prepare it for rewriting. \\

\vspace{5mm}

For the rewriting system I will be refering to definition of an L-system, the part containing information about the L-system, the axiom and the production rules.  

\end{flushleft}

\section{Environment and Tools}

\begin{flushleft}

This majority of the implementation of the L-system will be written in the C and C++ programming languages \cite{stroustrup2000c++}, and I will be using the modern Open Graphics Library or \gls{OpenGL}. The OpenGl framework is one of the industry standards for creating 3D graphics applications, and is a cross platform API for interacting with the \acrshort{gpu} in a low level way. The low level nature of OpenGL is important as some of the structures and models we are going to be displaying and simulating can be graphically intensive \cite{sellers2013opengl} \cite{movania2017opengl}. OpenGL was originally intended to be an \acrshort{api} for the C and C++ programming languages, and therefore we can have a programming language and graphics API which have a strong emphasis on performance.

\vspace{5mm}

There are also a number of libraries which will provide some extra functionality. The standard library for C and C++ provides many usefull structures and functions which will be incredibly usefull during the development process. For more specialised mathematics capabilities the \acrfull{glm} library holds many mathematics classes and functions for conveniently dealing with some 3D mathematics such as vectors, matrices and quaternions. Another important library is the \acrfull{glfw} which is a multiplatform \acrshort{api} for creating an managing user interface windows, events and user input \cite{glfwDocumentation}.

\vspace{5mm}

In order to keep track of changes and manage versions Git is a free and open source version control software, that is able to keep track of changes that have been made to the files within a project folder. It will be used to keep track of previous versions of the project throughout the development process. Git can be used in conjuction with Github, which is a online web application that stores git repositories. This acts as a backup as well as containing all previous versions of the project \cite{torvalds}.

\end{flushleft}

\section{The Need for a L-system Lexical Analyser and Parser}

\begin{flushleft}

Traditionally an interpreter in computing is a program that takes program code as input, where it is then analyzed and interpreted as it is encountered in the execution process. All of the previously encountered information is kept for later interpretations. The information about the program can be extracted by inspection of the program as a whole, such as the set of declared variables in a block, a function, etc \cite{wilhelm2010compiler}. In essence, the L-system rewriter contains a type of interpreter, this should not be confused with the interpreter that processes the resultant string using turtle graphics. Due to this confusion of terms I will refer the system containing the lexical analyser, L-system parser and the rewriter itself as the L-system rewriter. \\

\vspace{5mm}

A similarity can be drawn between traditional interpreted languages and the L-system rewriter. With the L-system rewriter we are defining a set of constant variables, a starting point and then some production rules. Once we have all of this information, we would like to interpret that information a number of times. \\
For instance, we may want to rewrite five generations of the L-system, but later on we may want to instead generate up to the tenth generation. So we don't want to have to throw all the previous information away and start from scratch, instead, we can go from the current state of the L-system rewriter and just rewrite another five times. If we would then like to get the resulting string we can just ask for it from the L-system rewriter. \\

\vspace{5mm}

The reason that a lexical analyser and parser are neccessary to carry out rewriting, is that without them it would be very difficult to find the syntactic roles of each part of the L-system, for example: F(2*3, x * (2 + y)), here we have a single module with two parameters one parameter has the expression (2 * 3) and the other has the expression (x * (2+y)), these kinds of complex structures within a grammar require some knowledge about the grammar it represents. The lexical analyser firstly makes sure that all the syntax within the L-system is correct, the parser splits the L-system into its component parts and is then able to describe each parts syntactic roll. This will provide the understanding that x and y are variables within a module and do not represent another module, as well as provide where it could find the value of x and y. For a \acrshort{cfg} like the parametric 0L-system grammar, creating an rewriter specifically designed for the L-system can make it simpler to debug any syntactic errors which a user may input, as well as make the string rewriting much faster. \\

\end{flushleft}

\section{The Syntax of a Parametric L-system}

\begin{flushleft}

This section will cover the syntax for the parametric L-system rewriter, the syntax for the parametric 0L-system is similar to the definition of the L-systems given by Prusinkiewicz and Lindenmayer in section \ref{definition of a parametric 0L-system section}. There are some additions and modifications to the syntax definition provided by Prusinkiewicz and Lindenmayer in order to construct a single L-system that includes branching, constant variable definitions, object specifications, parametric L-system concepts, randomness as well as stochastic L-systems \cite{prusinkiewicz2012algorithmic}. \\

\vspace{5mm}

A parametric L-system is made up of five major parts, which can be catagorised as statements, these statements are the define statements, include statements, a single generation statement, a single axiom statement and a one or more production rule statements. \cite{prusinkiewicz2013lindenmayer}. In order to make it easy for the lexer and parser, each statement will be started with a \# character and will end with a ; character. \\ 

\vspace{5mm}

The order in which statements should be listed is as follows: \\

\vspace{5mm}

\begin{equation} \label{statement order example}
\begin{aligned}
	&\text{\#generations statement;}\\
	&\text{\#define statements;}\\
	&\text{\hspace{10mm}...}\\
	&\text{\#include statements;}\\
	&\text{\hspace{10mm}...}\\
	&\text{\#axiom statement;}\\
	&\text{\#production statements;}\\
	&\text{\hspace{10mm}...}\\
\end{aligned}
\end{equation}

\vspace{5mm}

The generations statement can be defined anywhere within the L-system, however it is convension to put this at the top of the L-system in order to be clear how many generations we would like to rewrite. The define and include statements appear above the axiom and productions statements as they define values often used within the axiom and production rules. A single axiom is then defined followed by one or more production rules. \\

\vspace{5mm}

In order to make arithmatic less complicated, all numbers within the L-system are repersented as floating point numbers. Other data types could be added to the definition of the L-system, however, there is some added problems such as the conversion from one type to another as well as how you specify which data type you are defining. For all intent intents and purposes the floating point data type should provide all the neccessary functionality needed for the L-system.

\end{flushleft}

\section{Scanner - Flex} \label{Flex}

\begin{flushleft}

D. Cooper and L. Torczon write that "The scanner, or lexical analyser, reads a stream of characters and produces a streeam of words. It aggregates characters to form words and applies a set of rules to determin wheter or not each word is legal in the source language. If the word is valid, the scanner assigns it a syntactic category, or part of speech" \cite{cooper2011engineering}. \\

\vspace{5mm}

Writing a custom \gls{Lexer} can be quite complicated and time consuming to design and implement, and once a custom \gls{Lexer} has been created it can be difficult to change some functionality at a later stage. Luckely there is a well known program known as the \acrlong{flex} (\acrshort{flex}), \acrshort{flex} takes a .l file which contains the lexical rules of the language, it uses these rules to create a \gls{Lexer} program. When \acrshort{flex} is run it will create a \gls{Lexer} in the form of a C program. We can use the generated Lexer on the L-system that we would like to rewrite, taking the word within the L-system and assigning a syntactic category to it. The vaid syntactic categories are listed in the table below:

\begin{table}[h!] \center
\begin{tabular}{ | c | l | l |}
\hline
	Syntactic Word	& Syntactic Category & Meaning\\  
\hline
\hline
	, 				& T\_COMMA 				& Separation between module parameters \\
\hline
	: 				& T\_COLON 				& Separation between production rule parts \\
\hline
	; 				& T\_SEMI\_COLON 		& End of a statement\\
\hline
	\#				& T\_HASH 				& Beginning of a statement\\
\hline
	( 				& T\_PARENL 			& Start of a modules parameters \\
					&						& or specifies presidence in an expression \\
\hline
	) 				& T\_PARENR 			& End of a modules parameters \\
					&						& or specifies presidence in an expression \\
\hline 
	\{ 				& T\_BRACKETL 			& Start of a random range\\
\hline
	\} 				& T\_BRACKETR 			& End of a random range\\
\hline
	$\sim$ 			& T\_TILDE 				& Stochastic operator\\
\hline
	== 				& T\_EQUAL\_TO 			& Relational operator stating equal to\\
\hline
	!= 				& T\_NOT\_EQUAL\_TO 	& Relational operator for not equal to\\
\hline		
	$<$ 			& T\_LESS\_THAN 		& Relational operator for less than\\
\hline
	$>$ 			& T\_GREATER\_THAN 		& Relational operator for greater than\\
\hline
	$<$ = 			& T\_LESS\_EQUAL 		& Relational operator for greater or equal\\
\hline
	$>$ = 			& T\_GREATER\_EQUAL 	& Relational operator for greater or equal\\
\hline
	[ 				& T\_SQUARE\_BRACEL 	& Module name (branching save state) \\
\hline
	] 				& T\_SQUARE\_BRACER 	& Module name (branching load state) \\
\hline
	+ 				& T\_PLUS 				& Arithmetic operator for addition, or\\
					&						& Module name (Yaw right) \\
\hline
	- 				& T\_MINUS 				& Arithmetic operator for subtraction, or\\
					&						& Module name (Yaw left)\\
\hline
	/ 				& T\_FORWARD\_SLASH 	& Arithmetic operator for division, or\\
					&						& Module name (Pitch up)\\
\hline
	$\backslash$ 		& T\_BACK\_SLASH 		& Module name (Pitch down)\\
\hline
	* 				& T\_STAR 				& Arithmetic operator for multiplication, or\\
					&						& Condition in a production rule which is true\\
\hline
	$\land$ 		& T\_HAT 				& Arithmetic operator for and exponent, or\\
					&						& Module name (Roll right)\\
\hline
	$\&$ 			& T\_AMPERSAND 			& Module name (Roll left)\\
\hline
	! 				& T\_EXCLAMATION 		& Module name (Set size of branch)\\
\hline
	\$ 				& T\_DOLLAR 			& Module name \\
\hline
	= 				& T\_ASSIGN 			& Assignment operator used to set generations\\
\hline
	\#n 			& T\_GENERATIONS 		& Declaration of the number of generations\\
\hline
	\#w 			& T\_AXIOM 				& Declaration of the axiom\\
\hline
	[0-9]+\.[0-9]+|[0-9]+ 					& T\_FLOAT 				& Regular expression for a floating point number\\
\hline
	[a-zA-Z\_][a-zA-Z0-9\_]*  				& T\_VAR\_NAME 			& Regular expression for a module or variable name\\
\hline
\hline
\end{tabular}
\caption{Table of Valid Lexer Words}
\label{lexer words}
\end{table}
\FloatBarrier

From the table about there are a number of meanings to the grammar, for instance the ( and ) parenthesis have two meanings, it is either to specify the begining and end of a modules parameters or it specifies presidence within an expression. It is not up to the scanner to determine what the each particular parentheses meaning is, this is left up to the parser which is somewhat aware of the context of each syntactic word. \\

\vspace{5mm}

There are also the symbols [,],+,-,/,$\backslash$, $\land$, $\&$, ! and \$, these symbols are said to be valid module names, however it is also possible for a T\_VAR\_NAME to be a module name, this is becuase in some interpretations of the L-system these symbols are used to represent special meanings. This is the reason that the $\&$ word has the meaning \textit{roll left}. This does not mean that the scanner understands what the ampersand means, apart from the fact that it is a valid module name, the rest is left up to the interpreter.

\end{flushleft}

\section{Parser - Bison} \label{Bison}

The parsers job is to find out if the input stream of words from the \gls{Lexer} makes up a valid sentence in the language. The \gls{Parser} fits the syntactical category to the grammatical model of the language. If the \gls{Parser} is able to fit the syntactical category of the word to the grammatical model of the language then the syntax is seen to be correct. If all of the syntax is correct the \gls{Parser} will output a syntax tree and build the structures for use later on during the compilation process \cite{cooper2011engineering}.


\subsection{Constants and Objects}

\begin{flushleft}

Defining constants and objects is similar syntactically, the keyword define or include is used, followed by a variable name followed by a value, the value for a constant is a floating point number and the value for an include is a name of an object within the predefined object library. An example of the defining a constant and an object can be seen below: \\

\begin{equation} \label{constant and object example}
\begin{aligned}
	&\text{\#define num 10;}\\
	&\text{\#define pi 3.1415;}\\
	&\\
	&\text{\#include F BRANCH;}\\
	&\text{\#include S SPHERE;}\\
\end{aligned}
\end{equation}

The definition variables can be stored as a table, called a constants table, which keeps track of all of the constant variables defined by the L-system, the implementation for this thesis involved using a map data structure from the c++ standard library, where the index is the variable name string, and the value is the value associated with the variable as seen in the table below: \\

\vspace{5mm}

\begin{table}[h!] \center
\begin{tabular}{ | c | l | }
\hline
	Variable Name 	& Value\\  
\hline
\hline
	num 				& 10.0\\
\hline
	pi					& 3.1415\\
\hline
\end{tabular}
\caption{Table of turtle instruction symbols and their meaning to the interpreter}
\label{constants table}
\end{table}
\FloatBarrier

The object table structure also makes use of the Map structure and is very similar to the constants table, the object table holds the module name, and name of the object in the predefined object library. Which will not need to be used during rewriting but will be necessary during the interpretation of the resulting string. \\

\begin{table}[h!] \center
\begin{tabular}{ | c | l | }
\hline
	Module Name	& Object Name\\  
\hline
\hline
	F 				& BRANCH\\
\hline
	S				& SPHERE\\
\hline
\end{tabular}
\caption{Table of turtle instruction symbols and their meaning to the interpreter}
\label{constants table}
\end{table}
\FloatBarrier



\end{flushleft}

\subsection{Modules and Strings}

\begin{flushleft}

For the purposes of the rewriter it is important to understand that there are three major parts of a module, there is a module name, which is a single character or symbol, secondly part is the list of parameters, an open parentheses, signifies the begining of these parameters, where there can be one or more parameters listed. Thirdly, each parameter can either be made up of a number, variable, random number range or a mathematical expression containing of numbers, variables and parentheses signifying precedence. Finally the modules end is specified by a close parentheses. \\   

\vspace{5mm}

There are two types of modules, one being a module definition and the other a module call. The module definition stands as a type of template of a module within a production rule, these templates do not have to hold actual values but the values will be substituted during the rewriting process. The module calls would appear either in the axiom or in the resultant string, the parameters of a module call will hold an actual numerical value. Below is an example outlining the difference between the module definition and module calls.\\ 

\begin{equation} \label{module definition and call example}
\begin{aligned}
	&\text{\#w : A(10);}\\
	&\text{\#p1 : A(x) : * : A(x)A(x); }\\
\end{aligned}
\end{equation}

In example \ref{module definition and call example} above, the module A(10) within the axiom, is a module call, as it contains the numerical value of 10 in the first parameter. In the production rule p1 the module A(x) within the predecessor is a module definition, it states that module A's first parmeter has a local variable x, the calling modules value will substitute x and will replace the value of x anywhere within the successor statement, p1's successor has two modules A(x)A(x), also module defintions however the value x will be subtituted with the calling modules value. When a production rules successor rewrites the calling module, the successors modules must have a numerical value, they then become module calls within the resultant string. \\ 

\vspace{5mm}

A string in the context of a parametric L-system is a vector of modules, this being the C++ standard library vector data structure. The modules are linked one after the other creating a type of string, but instead of characters or symbols we have a string of modules. \\

\end{flushleft}

\subsection{Building a Generalised L-system Grammar}

We are now able to represent complex three dimensional tree structures in the form of a L-system rule set. In a computing sense this rule set can be seen as a type of program. In the program we define the number of generations we would like to generate, the starting point (Axiom) some constant varables (\#define) and the set of production rules. \\
Using this information, we iterate through the from generation to generation rewritting the strings and then at the end provide a resulting string which will then be interpreted and displayed on the screen.
\\
We can represent the languages grammar in the form of a \acrlong{bnf}, \acrshort{bnf} is a notation for \acrlong{cfg}s used to describe the syntax of different languages. In this case the \acrshort{bnf} is used below to describe the syntax of the parametric L-system grammar. \\
\\
For example: \\ 
\\
\textless expression\textgreater~ $\rightarrow$ number \\ 
\textless expression\textgreater~ $\rightarrow$ (\textless expression\textgreater~) \\
\textless expression\textgreater~ $\rightarrow$ \textless expression\textgreater~ + \textless expression\textgreater~ \\
\textless expression\textgreater~ $\rightarrow$ \textless expression\textgreater~ - \textless expression\textgreater~ \\
\\
The first line states that an \textless expression\textgreater~ can be any number, line two states that an \\ \textless expression\textgreater~ can also be an expression that is inside parenthesis. Line three states that an \\ \textless expression\textgreater~ can be an \textless expression\textgreater~ added to another \textless expression\textgreater~, furthermore line four states that an \textless expression\textgreater~ can also be an \textless expression\textgreater~ subtracted by another \textless expression\textgreater~. \\
\\
The above grammar can be expressed as follows: \\
\\
\textless expression\textgreater~ $\rightarrow$ number 

\hspace{2cm} $|$ (\textless expression\textgreater~) 

\hspace{2cm} $|$ \textless expression\textgreater~ + \textless expression\textgreater~ 

\hspace{2cm} $|$ \textless expression\textgreater~ - \textless expression\textgreater~ \\
\\
Here the $|$ symbol can be articulated as an OR, therefore it can be said that an \textless expression\textgreater~ can be a number OR an \textless expression\textgreater~ surrounded by parenthesis, OR an \textless expression\textgreater~ added to another \textless expression\textgreater~ OR an \textless expression\textgreater~ subtracted by another \textless expression\textgreater~. 
\\
In addition to this, any statement that is not surrounded by \textless \textgreater, states it must match that particular string. The $\in$ followed by an $|$ states that it can either be nothing or another statement. \\
\\

\subsection{\acrlong{bnf} of the L-system Grammar} \label{L-system Grammar}

% Program 
\noindent
\textless prog\textgreater~ $\rightarrow$ $\in$ 

\hspace{2cm} $|$  \textless stmts\textgreater~ EOF \\



% Statements
\noindent
\textless stmts\textgreater~ $\rightarrow$ $\in$

\hspace{2cm} $|$ \textless stmt\textgreater~ \textless stmts\textgreater~ \\


% Statement
\noindent
\textless stmt\textgreater~ $\rightarrow$ EOL 

\hspace{2cm} $|$ \textless generations\textgreater~

\hspace{2cm} $|$ \textless definition\textgreater~

\hspace{2cm} $|$ \textless axiom\textgreater~

\hspace{2cm} $|$ \textless production\textgreater~\\



% Generations
\noindent
\textless generations\textgreater~ $\rightarrow$ \#n = \textless float\textgreater~ ; \\



% Definitions
\noindent
\textless definition\textgreater~ $\rightarrow$  \#define \textless variable\textgreater~ \textless float\textgreater~ ;

\hspace{2cm} $|$ \#define \textless variable\textgreater~ + \textless float\textgreater~ ;

\hspace{2cm} $|$ \#define \textless variable\textgreater~ -\textless float\textgreater~ ; \\



% Axiom
\noindent
\textless axiom\textgreater~ $\rightarrow$  \#w : \textless axiom statement list\textgreater~ ; \\



% Axiom Statement List
\noindent
\textless axiom statement list\textgreater~ $\rightarrow$ $\in$ 

\hspace{2cm} $|$ \textless axiom statement\textgreater~ \textless axiom statement list\textgreater~ ; \\



% Axiom Statement
\noindent
\textless axiom statement\textgreater~ $\rightarrow$ \textless moduleAx\textgreater~ \\



% Axiom Module 
\noindent
\textless moduleAx\textgreater~  $\rightarrow$ \textless variable\textgreater~ $|$ "$+$" $|$ "$-$" $|$ "/" $|$ "$\backslash$" $|$ "\textasciicircum" $|$ "$\&$" $|$ "!" 

\hspace{2cm} $|$ \textless variable\textgreater~ (  \textless paramAx\textgreater~ \textless paramListAx\textgreater~ )

\hspace{2cm} $|$ +(  \textless paramAx\textgreater~ \textless paramListAx\textgreater~ ) 

\hspace{2cm} $|$ -(  \textless paramAx\textgreater~ \textless paramListAx\textgreater~ ) 

\hspace{2cm} $|$ /(  \textless paramAx\textgreater~ \textless paramListAx\textgreater~ ) 

\hspace{2cm} $|$ $\backslash$(  \textless paramAx\textgreater~ \textless paramListAx\textgreater~ )

\hspace{2cm} $|$ \textasciicircum (  \textless paramAx\textgreater~ \textless paramListAx\textgreater~ ) 

\hspace{2cm} $|$ $\&$(  \textless paramAx\textgreater~ \textless paramListAx\textgreater~ ) \\



% Axiom Parameter List
\noindent
\textless paramAxList\textgreater~ $\rightarrow$  $\in$ 

\hspace{2cm} $|$ , \textless paramAx\textgreater~ \textless paramAxList\textgreater~ \\



% Axiom Parameter
\noindent
\textless paramAx\textgreater~ $\rightarrow$ \textless expression\textgreater~ \\



% Production
\noindent
\textless production\textgreater~ $\rightarrow$  \# \textless variable\textgreater~  : \textless predecessor\textgreater~ : \textless condition\textgreater~  : \textless successor\textgreater~ ;\\



% Predecessor
\noindent
\textless predecessor\textgreater~ $\rightarrow$ \textless pred statement list\textgreater~ \\


% Predecessor Statement List
\noindent
\textless pred statement list\textgreater~ $\rightarrow$ $\in$

\hspace{2cm} $|$ \textless pred statement\textgreater~ \textless pred statement list\textgreater~ \\


% Predecessor Statement
\noindent
\textless pred statement\textgreater~ $\rightarrow$ \textless module\textgreater~ \\



% Condition 
\noindent
\textless condition\textgreater~ $\rightarrow$ *

\hspace{2cm} $|$ \textless left expression\textgreater~ \textless conditions statement\textgreater~ \textless right expression\textgreater~ \\


% Condition Left Expression
\noindent
\textless left expression\textgreater~ $\rightarrow$ \textless expression\textgreater~ \\


% Condition Right Expression
\noindent
\textless right expression\textgreater~ $\rightarrow$ \textless expression\textgreater~ \\


% Condition Statement
\noindent
\textless condition statement\textgreater~ $\rightarrow$ == $|$ != $|$ \textless $|$ \textgreater $|$ \textless = $|$ \textgreater =\\



% Successor
\noindent
\textless successor \textgreater~ $\rightarrow$ \textless successor statement list \textgreater~ \\


% Successor Statement List
\noindent
\textless successor statement list\textgreater~ $\rightarrow$ $\in$

\hspace{2cm} $|$ \textless successor statement\textgreater~ \textless successor statement list \textgreater~ \\


%Successor Statement
\noindent
\textless successor statement\textgreater~ $\rightarrow$ \textless module\textgreater~ \\



% Module
\noindent
\textless module\textgreater~ $\rightarrow$  \textless variable\textgreater~ $|$ $+$ $|$ $-$ $|$ / $|$ $\backslash$ $|$ \textasciicircum $|$ $\&$ $|$ ! 

\hspace{2cm} $|$ \textless variable\textgreater~ (  \textless param\textgreater~ \textless paramList\textgreater~ )

\hspace{2cm} $|$ +(  \textless param\textgreater~ \textless paramList\textgreater~ )

\hspace{2cm} $|$ -(  \textless param\textgreater~ \textless paramList\textgreater~ )

\hspace{2cm} $|$ /(  \textless param\textgreater~ \textless paramList\textgreater~ ) 

\hspace{2cm} $|$ $\backslash$(  \textless param\textgreater~ \textless paramList\textgreater~ ) 

\hspace{2cm} $|$ \textasciicircum (  \textless param\textgreater~ \textless paramList\textgreater~ ) 

\hspace{2cm} $|$ $\&$(  \textless param\textgreater~ \textless paramList\textgreater~ ) \\



% Parameter List
\noindent
\textless paramList\textgreater~ $\rightarrow$ $\in$ $|$ : \textless param\textgreater~ \textless paramList\textgreater~ \\



%Parameter List
\noindent
\textless param\textgreater~ $\rightarrow$ \textless expression\textgreater~ \\



% Expression
\noindent
\textless expression\textgreater~ $\rightarrow$  \textless variable\textgreater~

\hspace{2cm} $|$ \textless float\textgreater~

\hspace{2cm} $|$ \textless expression\textgreater~ + \textless expression\textgreater~

\hspace{2cm} $|$ \textless expression\textgreater~ - \textless expression\textgreater~

\hspace{2cm} $|$ \textless expression\textgreater~ * \textless expression\textgreater~

\hspace{2cm} $|$ \textless expression\textgreater~ / \textless expression\textgreater~

\hspace{2cm} $|$ \textless expression\textgreater~ \textasciicircum \textless expression\textgreater~

\hspace{2cm} $|$ "(" \textless expression\textgreater~ ) \\



% Float
\noindent
\textless float\textgreater~ $\rightarrow$ [0-9]+.[0-9]+ \\



% Variable
\noindent
\textless variable\textgreater~ $\rightarrow$ [a-zA-Z\_][a-zA-Z0-9\_]* \\



\section{Displaying the L-system Instructions} \label{Display L-system Instructions}

\subsection{Basic 2D L-systems} 

There are a number of fractal geometry that have become well known particularly with regards to how they can seemingly imitate nature \cite{mandelbrot1982fractal}. Particularly with the geometry such as the Koch snowflake which can be represented using the following L-system.

\begin{figure}[htbp]
	\raggedright
	\textbf{\underline{Koch Curve:}} \\
	\#n = 4; \\
	\#define r 90; \\
	\#w : F(1); \\
	\#p1 : F(x) : * : F(x)+(r)F(x)-(r)F(x)-(r)F(x)+(r)F(x);\\
	{\centering
		\vspace{7px}
		\includegraphics[scale=0.15]{KochCurve/KochCurve04.png}
		\caption{Koch Curve.}
	}
\end{figure}
\begin{figure}[htbp]
	\raggedright
	\textbf{\underline{Sierpinski Triangle:}} \\
	\#n = 4;\\
	\#define r 60;\\
	\#w : F(1);\\
	\#p1 : F(x) : * : X(x)-(r)F(x)-(r)X(x);\\
	\#p2 : X(x) : * : F(x)+(r)X(x)+(r)F(x);\\
	{\centering
		\vspace{7px}
		\includegraphics[scale=0.15]{SierpinskiTriangle/SierpinskiTriangle04.png}
		\caption{Sierpinski Triangle.}
	}
\end{figure}
\begin{figure}[htbp]
	\raggedright
	\textbf{\underline{Fractal Plant:}} \\
	\textbf{Alphabet:} X, F\\
	\textbf{Constants:} +, -, [, ] \\
	\textbf{Axiom:} X \\
	\textbf{Angle:} 25$^\circ$ \\
	\textbf{Rules:} \\
	X $\rightarrow$ F-[[X]+X]+F[+FX]-X\\
	F $\rightarrow$ FF \\
	{\centering
		\vspace{7px}
		\includegraphics[scale=0.15]{FractalPlant/FractalPlant05.png}
		\caption{Fractal Plant.}
	}
\end{figure}
\begin{figure}[htbp]
	\raggedright
	\textbf{\underline{Fractal Bush:}} \\
	\textbf{Alphabet:} F\\
	\textbf{Constants:} +, -, [, ] \\
	\textbf{Axiom:} F \\
	\textbf{Angle:} 25$^\circ$ \\
	\textbf{Rules:} \\
	F $\rightarrow$ FF+[+F-F-F]-[-F+F+F]\\
	{\centering
		\vspace{7px}
		\includegraphics[scale=0.15]{FractalBush/FractalBush06.png}
		\caption{Fractal Bush.}
	}
\end{figure}

\FloatBarrier

\subsection{The Use of L-systems in 3D applications}

\begin{flushleft}

L-systems have been talked about and researched since its inception in 1968 by Aristid Lindenmayer. Over the years it's usefulness in modelling different types of plant life has been very clear, however its presence has been quite absent from any mainstream game engines for the most part, these engines relying either on digital artists skill to develop individual plants or on 3rd party software such as SpeedTree. These types of software use a multitude of different techniques however their methods are heavily rooted in Lindenmayer Systems. 

\end{flushleft}

\newpage